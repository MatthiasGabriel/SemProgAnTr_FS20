\section{Dependent Types}
\subsection{Introduction to dependent types}
There are different kinds of dependent types. The two most common ones are $\Sigma$-types and $\Pi$-types.
The first focus lies on the $\Pi$-types, which are also used in the first example in section \ref{section_dependent_types_example}. These types are sometimes also called \emph{dependent function types} as in \cite{10.1145/2841316} or \emph{dependent product type} as in \cite{10.5555/1076265}. Be aware that the name dependent product type can also be used for $\Sigma$-types as in \cite{10.1145/2841316}.

In the example from the introduction in chapter \ref{section:introduction} where the length of a list is specified directly in the type. This data structure is in the literature often called vector \cite{10.1145/2841316} \cite{10.5555/1076265}.
This new data structure is not a simple type but maps an input of type \emph{Nat} to a specific type. To differentiate between such as structure and types the term \emph{type family} is used as suggested by Aspinall and Hofmann in \cite{10.5555/1076265}.

$$Vector :: Nat \rightarrow *$$

The type which contains vectors of length \emph{k} can be constructed by applying \emph{k} to \emph{Vector} or in other terms \emph{Vector k}.

To construct new Vectors two constructors are needed. 
One which constructs an empty vector and one to add new elements to the vector. 
This pattern should be familiar for everyone that is used to functional programming so far.

The second constructor \emph{cons} takes one element \emph{n} of type \emph{Nat}, an element of type \emph{data} as well as a vector with the length \emph{n} and returns a new vector of length \emph{n+1}. 
The length of the returned vector is increased by one to account for the new element that is added.

$$empty: Vector \, 0$$
$$cons : \Pi n : Nat. \, data \rightarrow Vector \, n \rightarrow Vector \, (n+1)$$

Dependent function types can be described as $\Pi x : A. B$ where x can be used to define B. 
This is the generalization of the arrow type used in simply typed lambda-calculus. Every arrow type can also be expressed as a $\Pi$-type.

\todo{Verify}
$$A \rightarrow B \, = \, \Pi x:A.B$$
$$where \, x \, does \, not \, appear \, free \, in \, B$$

Another description of the $\Pi$-type is the following. A function maps an element $a \in A$ to a new element $b \in B_a$. 
This is also called type B is indexed by type A \cite{10.1145/2841316}.

\todo{Extend this with relation to Curry-Howard Isomorphism/Correspondence as universal quantification}

This additional information that is now encoded in the type can be exploited whenever such a type is used. As a first example, let us define the function first which returns the first element of a vector.
In contradiction to lists, it is now possible to specify that only non-empty vectors can be be used as an argument. 
This simplifies the implementation of \emph{first} and also each usage of \emph{first} as no exception handling for the empty data structure is necessary. 
If the function can be called with a specific instance then it is guaranteed by the type system that an instance of data is returned.

$$first : \Pi n : Nat.Vector(n+1) \rightarrow data$$


To be more clear what this means in practice lets consider a few examples in Agda.

\subsection{Example in Agda}\label{section_dependent_types_example}
In this chapter, the first dependent datatype in Agda the vector will be defined.
It is essentially a list but in contrast to the list datatype defined in chapter \ref{section:agda_introduction_example} the length of the list is a part of the type.

In addition to the implicit type-level and the type A, an additional parameter of type $\mathbb{N}$ is defined in the type definition as shown in code snippet \ref{codeSnippet:vector_datatype}.

\begin{codesnippet}[mathescape=true, caption={Definition of the vector datatype in Agda}, label={codeSnippet:vector_datatype}]
data $\mathbb{V}$ {$\ell$} (A : Set $\ell$) : $\mathbb{N}$ $\rightarrow$ Set $\ell$ where
  [] : $\mathbb{V}$ A zero
  _::_ : {n : $\mathbb{N}$} (x : A) (xs: $\mathbb{V}$ A n) $\rightarrow$
         $\mathbb{V}$ A (suc n)
\end{codesnippet}

There is a difference between \emph{parameters}, used before the colon, and \emph{indices} of a datatype.
The datatype $\mathbb{V}$ is parameterised by a type A and indexed over $\mathbb{N}$\cite{norell:deptyped}.
Parameters are required to be exactly the same for each constructor of a datatype, however, indicies can vary.

The first constructor for the empty vector sets the length of the vector to the fixed value zero of $\mathbb{N}$ because it is known that the list is currently empty and the length is therefore 0.
The second constructor is used to add new elements to an existing vector. It takes two arguments one of type A and one of type $\mathbb{V}$ A n similar to the list but additionally it determines the implicit argument n of type $\mathbb{N}$ from the input vector.
This parameter is then used to define the return type. As exactly one new element is added to the existing list of type $\mathbb{V}$ A n it is known that the new type has to be $\mathbb{V}$ A (suc n).

Appending two vectors - as seen in code snippet \ref{codeSnippet:vector_append} - is a mix between the appending of two lists and the datatype definition of the vector and relatively straightforward.

\begin{codesnippet}[mathescape=true, caption={Definition of the vector append function in Agda}, label={codeSnippet:vector_append}]
_++$\mathbb{V}$_ : $\forall$ {$\ell$} {A : Set $\ell$}  {n m: $\mathbb{N}$ $\rightarrow$
        $\mathbb{V}$ A n $\rightarrow \mathbb{V}$ A m $\rightarrow \mathbb{V}$ A (n + m)
  []        ++$\mathbb{V}$ ys = ys
  (x :: xs) ++$\mathbb{V}$ ys = x :: (xs ++$\mathbb{V}$ ys)
\end{codesnippet}

To prevent a naming conflict between the append operators of lists and vectors the unique name \_++$\mathbb{V}$\_ was chosen.

It is important, that the types of these two vectors does not need to be equal, as the parameters n and m of type $\mathbb{N}$, which are also a part of the types, can have different values. 
Nevertheless the elements contained in both vectors are still required to be of type A.

It can be deduced that the newly constructed vector has the type $\mathbb{V}$ A (n + m).

The next example will present the first benefit of including the length in the datatype.
In case of the list datatype $\mathbb{L}$, it was required to define an additional helper datatype \emph{maybe} as described in section \ref{section:agda_introduction_example} when implementing the \emph{nth} function.
Additionally, whenever a programmer uses the function, he has to think of the different cases \emph{nothing} or \emph{just} and adjust his functionality. This is done with additional pattern matching.

The same restrictions are met by the \emph{head} function of a $\mathbb{L}$. 
However, the \emph{head} function of $\mathbb{V}$ shown in code snippet \ref{codeSnippet:vector_head} always returns a single object of type A.

\begin{codesnippet}[mathescape=true, caption={Definition of $head\mathbb{V}$ function in Agda}, label={codeSnippet:vector_head}]
head$\mathbb{V}$ : $\forall$ {$\ell$} {A : Set $\ell$} {n : $\mathbb{N}$} $\rightarrow$ 
        $\mathbb{V}$ A suc(n) $\rightarrow$ A
head$\mathbb{V}$ (x :: _) = x
\end{codesnippet}

This is possible by using the additional information of the implicit parameter \emph{n} of type $\mathbb{N}$, respectivelly by restricting the input vector to the type $\mathbb{V}$ A suc(n).
Elements of this type are known to have a least one entry, in this case the implicit parameter would be zero.

It is possible to define the \emph{head} without specificing a pattern for the empty vector [] as the type checker can infer that this case is not possible.
Whenever a particular case is type correct it is necessary to include it, otherwise it needs to be omitted \cite{norell:deptyped}.

Similar to \emph{head$\mathbb{V}$} the function \emph{nth$\mathbb{V}$} in code snippet \ref{codeSnippet:vector_nth} has an implicit parameter m of type $\mathbb{N}$ which represents the length of the input vector. 
Additionally it contains the second explicit parameter is a proof that n is less than m.

\begin{codesnippet}[mathescape=true, caption={Definition of \emph{nth} function in Agda}, label={codeSnippet:vector_nth}]
nth$\mathbb{V}$ : $\forall$ {$\ell$} {A : Set $\ell$} {m : $\mathbb{N}$} $\rightarrow$
       (n : $\mathbb{N}$) $\rightarrow$ n < m $\equiv$ tt $\rightarrow \mathbb{V}$ A m $\rightarrow$ A
nth$\mathbb{V}$ zero _ (x :: _) = x
nth$\mathbb{V}$ (suc n) p (_ :: xs) = nth$\mathbb{V}$ n p xs
nth$\mathbb{V}$ (suc n) () []
nth$\mathbb{V}$ zero () []
\end{codesnippet}

The base case of the \emph{nth$\mathbb{V}$} recursive function is at line 3. It states that if the element at index 0 is wanted, the head of the list is returned.
To indicate that the proof, that zero is smaller than length of the vector, as well as the tail of the vector are not used in the definition of the function they are replaced by an \_.

At line 4 the recursive case is defined which calls \emph{nth$\mathbb{V}$} but with the predecessor of n and the tail of the current vector.
The second argument \emph{p}, which contains the proof that $suc(n)$ is smaller than the length of the vector, is directly passed into the new function call. 
At first glance, this might look a little bit unusual. 
It is possible because, both the index as well as the length of the new vector \emph{xs} are decreased by exactly one, the proof still holds.
The proof \emph{p} is still valid as \emph{suc n $<$ suc m $\equiv$ tt} and \emph{n $<$ m $\equiv$ tt} are definitionally equal.

The last two lines look quite different than any of the definitions before.
Because it is not possible to prove that \emph{suc n $<$ m $\equiv$ tt} where m is the length of the empty list, or more concretely zero, the so-called absurd pattern can be used. 
This basically tells Agda that this case can never be reached and therefore no definition for this case has to exist.
The last line is required lies in the definition of \_$<$\_ of $\mathbb{N}$ shown in code snippet \ref{codeSnippet:natural_number_less_than}.
Because in that definition a case distinction between $0 < 0$ and $\text{(suc x)} < 0$ was made, the last line, which proves that \emph{zero $<$ zero $\equiv$ tt} is false, is required as well.

Whenever the function \emph{nth$\mathbb{V}$} is called, a proof that m $<$ n is equivalent to tt is required as shown in code snippet \ref{codeSnippet:vector_nth_usage}. This can easily be done by using refl.


\todo{state that a digit representation is possible without going into details about pragmas. Maybe in the agda section.}
\begin{codesnippet}[mathescape=true, caption={Usage of \emph{nth} function in Agda}, label={codeSnippet:vector_nth_usage}]
test-vector = ff :: ff :: []
element = nth$\mathbb{V}$ (suc zero) refl test-vector

invalid_element = nth$\mathbb{V}$ (suc(suc zero)) refl test-vector
\end{codesnippet}

The code snippet \ref{codeSnippet:vector_nth_usage} will not compile as the proof refl in the call on the last line is invalid as \emph{suc(suc zero) $<$ suc(suc zero) $\equiv$ ff}.

\subsection{$\Sigma$-types}
In addition to $\Pi$-types, there exists a second important class of dependent types. 
The $\Sigma$-types also called \emph{dependent product types}\cite{10.1145/2841316},\emph{dependent pair types}\cite{10.1145/2841316} or \emph{dependent sum types}\cite{10.5555/1076265}.

A $\Sigma$-type is the generalization of the ordinary product type. 
It is basically a combination of two types where each element of this type is a pair. 
But the type of the second element of the pair may depend on the value of the first element.

\todo{Verify}
$$\Sigma x: A.B \,= \, A \times B$$
$$where \, x \, does \, not \, appear \, free \, in \, B$$


Another good description of the $\Sigma$-type is the following. 
Elements of the type are pairs $(a, b)$ under the condition that $a \in A$ and $b \in B_a$.

\todo{Extend this with relation to Curry-Howard Isomorphism/Correspondence as existential quantification}
Dependent $\Sigma$-types are often used to express an element with a certain property and its corresponding proof.
\todo{maybe add an example}

\subsection{$\Sigma$-types in Agda}
The simplest example for $\Sigma$-types in Agda is the type of nonzero Peano numbers.
It is directly based on the Peano numbers $\mathbb{N}$ defined in section \ref{section:agda_introduction_example}.

The definition of $\mathbb{N}^+$ states that each element is a pair of a Peano number combined with the proof that this specific number applied to the \emph{iszero} function returns false.

\begin{codesnippet}[mathescape=true, caption={Definition of nonzero Peano numbers in Agda}, label={codeSnippet:nonzero_natural_number}]
$\mathbb{N}^+$ : Set
$\mathbb{N}^+$ = $\Sigma$ $\mathbb{N}$ ($\lambda$ n $\rightarrow$ iszero n $\equiv$ ff)
\end{codesnippet}

The $\Sigma$ used in code snippet \ref{codeSnippet:nonzero_natural_number} from IAL is a simplification of the one defined in the standard library of Agda and only consists of three lines shown in code snippet \ref{codeSnippet:sigma}.

The $\Sigma$ type constructor takes two explicit and two implicit arguments. 
The first type argument is the type A of level $\ell$, the second type argument is a function of type B which takes an element of A and returns a new type of level $\ell '$.
The type level of $\Sigma$ will be at $\ell$ $\sqcup$ $\ell '$. The operator $\sqcup$ is part of Agda's primitive level system and takes the maximum of the two input levels.

The constructor for new elements of type $\Sigma$ is a single comma, which allows it to express $\Sigma$ elements as pairs.
The  usage of the variable a of type A in the type definition of b shows the direct dependence of the second component to the value of the first component.

\begin{codesnippet}[mathescape=true, caption={Definition of $\Sigma$ in Agda}, label={codeSnippet:sigma}]
data $\Sigma$ {$\ell$ $\ell '$} (A : Set $\ell$) (B : A $\rightarrow$ Set $\ell '$)
 : Set ($\ell$ $\sqcup$ $\ell '$) where
_,_ : (a : A) $\rightarrow$ (b : B a) $\rightarrow$ $\Sigma$ A B
\end{codesnippet}

Code snippet \ref{codeSnippet:nonzero_natural_number_suc} contains the successor function of $\mathbb{N}^+$ which returns the next nonzero Peano number.
As an input argument, the function takes an element of $\mathbb{N}^+$ and returns a new element $\mathbb{N}^+$. 
With pattern matching the element of $\mathbb{N}^+$ is disassembled into the number x and the proof p as defined in code snippet \ref{codeSnippet:nonzero_natural_number}.

The return value is constructed by applying the function \emph{suc} to the variable x as the first part of the pair and the \emph{refl} proof as the second part of the pair.
Agda can prove that \emph{iszero (suc x)} is always false and therefore the proof is as simple as refl.

\begin{codesnippet}[mathescape=true, caption={Successor of $\mathbb{N}^+$}, label={codeSnippet:nonzero_natural_number_suc}]
suc$^+$ : $\mathbb{N}^+$ $\rightarrow$ $\mathbb{N}^+$
suc$^+$ (x, p) = (suc x, refl)
\end{codesnippet}