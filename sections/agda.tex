\section{First steps in Agda}\label{section:first_steps_in_agda}
In the following chapter, a brief introduction to Agda is given. If you are experienced in any functional programming, it will be a short read or you might even skip some parts.

\subsection{Preliminaries}
Agda is an advanced functional programming language. Its syntax is strongly related to Haskell but it differs concept-wise in some topics. 

One thing to mention is that Agda supports the full Unicode characters in the source code with only a few reserved symbols\footnote{\, . ; \{ \} ( ) @ " are reserved symbols\cite{AgdaReadTheDocsStructure}} 
and some reserved keywords\footnote{A full list of reserved keywords can be found at \cite{AgdaReadTheDocsStructure}}. 
Unicode symbols will be used a lot, especially for mathematical symbols.

Another important thing to mention is the integration into emacs, which works as an IDE and supports syntax highlighting as well as many agda specific features some of which are pointed out in this publication.

\subsection{Introductory example}\label{section:agda_introduction_example}
\subsubsection{Datatype Definitions}
Lets first look at the datatype definition for Peano natural numbers $\mathbb{N}$ shown in code snippet \ref{codeSnippet:natural_number}.

\begin{codesnippet}[mathescape=true, caption={Definition of the peano natural numbers datatype in Agda}, label={codeSnippet:natural_number}]
data $\mathbb{N}$: Set where
  zero : $\mathbb{N}$
  suc  : $\mathbb{N} \rightarrow \mathbb{N}$
\end{codesnippet}

\todo{Add reference to explanation of set and $\ell$}
To define a new datatype it is required to specify the name of the type after the keyword \emph{data}.
Separated by a colon the type of the new datatype is defined - normally this is \emph{Set}.
\emph{Set} is a special kind of type which is the type of types.
It is required to specify the type of this new datatype because in Agda every expression has a type \cite{norell:deptyped}.

After this basic definition two different constructors \emph{zero} and \emph{suc} are defined as shown in code snippet \ref{codeSnippet:natural_number}.
There is little meaning in this short definition other than elements constructed with these operations are of type $\mathbb{N}$.
The only additional information is that \emph{suc} requires another $\mathbb{N}$ to be constructed.

Elements of $\mathbb{N}$ can now be constructed by calling the constructors and used in functions with pattern matching. 
Code snippet \ref{codeSnippet:natural_number_constructor} shows the basic usage of the two different constructors.

\begin{codesnippet}[mathescape=true, caption={Some peano numbers}, label={codeSnippet:natural_number_constructor}]
x = zero
y = suc zero
z = suc (suc (suc zero))
\end{codesnippet}

\subsubsection{Mixfix Operators}
Addition of Peano numbers can be defined in a very elegant way as an infix operator as shown in code snippet \ref{codeSnippet:natural_number_addition}.

\begin{codesnippet}[mathescape=true, caption={Peano numbers addition}, label={codeSnippet:natural_number_addition}]
_+_ : $\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}$
zero  + n = n
suc m + n = suc (m + n)
\end{codesnippet}

Infix operators are functions which can be used in between its arguments in which the underscores determines the place of its arguments.
Alternativelly it is also possible to call these functions in the normal prefix notation, but in this case the underscores are mandatory\footnote{In case of the \_+\_ the infix call is $n + m$ and the equivalent prefix call is $\text{\_+\_} n m$}.

Infix operators are a special case of mixfix operators where the operator is in between the arguments.
However, mixfix operators are not restricted to two arguments, but allow more complex constructs such as $\text{if\_then\_else\_}$ \cite{AgdaReadTheDocs}.

To be able to use multiple infix operators in the same expression it is necessary to specify the precedence of these.
With the three different keywords \emph{infix}, \emph{infixr} and \emph{infixl} the precedence as well as the associativity of the operator can be defined\footnote{The precendence factor defaults to 20 and can also be negative.}.

\begin{codesnippet}[mathescape=true, caption={Precedence and associativity of some Peano number operators}, label={codeSnippet:natural_number_precedence}]
infixl 40 _+_
infixl 20 _<_
\end{codesnippet}

An additional function for Peano numbers which is used in this publication is the comparison function shown in code snippet \ref{codeSnippet:natural_number_less_than}.

\begin{codesnippet}[mathescape=true, caption={Peano numbers less-than}, label={codeSnippet:natural_number_less_than}]
_<_ : $\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{B}$
0 < 0 = ff
0 < (suc y) = tt
(suc x) < (suc y) = x < y
(suc x) < 0 = ff
\end{codesnippet}

The \_\textless\_ function follows the same structure as the \_+\_ function, but includes four different pattern matching cases. 
This might not be the smallest possible definition possible but it is very precise and comprehensible.

\todo{Maybe replace tt with true and ff with false which in my opinion is nicer}
The boolean datatype $\mathbb{B}$ consists of two constructors \emph{tt} (representing true) and \emph{ff} (representing false) is shown in code snippet \ref{codeSnippet:boolean} for completeness.

\begin{codesnippet}[mathescape=true, caption={Definition of the boolean datatype in Agda}, label={codeSnippet:boolean}]
data $\mathbb{B}$: Set where
  tt : $\mathbb{B}$
  ff  : $\mathbb{B}$
\end{codesnippet}

\subsubsection{Type Parameters}
The definition of the list datatype as seen in code snippet \ref{codeSnippet:list_datatype} is more complex than the previous datatype definitions of $\mathbb{B}$ and $\mathbb{N}$ as it contains a type parameter.
The application of another type to the list datatype results in an own unique type, this concept is called type-level function.

\todo{Verify that this is a type-level function}

\begin{codesnippet}[mathescape=true, caption={Definition of the list datatype in Agda}, label={codeSnippet:list_datatype}]
data $\mathbb{L}$ {$\ell$} (A : Set $\ell$) : Set $\ell$ where
  [] : $\mathbb{L}$ A
  _::_ : (x : A) (xs: $\mathbb{L}$ A) $\rightarrow \mathbb{L}$ A
\end{codesnippet}

\todo{Explain $\ell$}
In this specific example, the function takes any type A at the type level $\ell$ and returns a new type, the concrete list type of A, at the same type level.\todo{research why this is required.}
For example $\mathbb{L}$ $\mathbb{N}$ for the list of Peano numbers.

$\ell$ is just an additional argument but with the usage of curly braces around $\ell$, it is indicated that it is an implicit argument and should be inferred by Agda.
There is no guarantee that the type checker is able to infer implicit arguments and it fails otherwise.
But it is always possible to specificy the implicit arguments in the call by enclosing the argument in curly braces\cite{norell:deptyped}.

When a parameter in a datatype definition is declared it can be used in the types of the constructors. 
For example, the second constructor is defined as a function that takes an argument x of type A and a second argument xs of type $\mathbb{L}$ A and returns a new $\mathbb{L}$ A where A is exactly the type that was used to construct the type of the list.

With the help of the two constructors, it is possible to construct any possible list. 
The next function to consider is $\_++\_$ which appends two lists of the same type show in code snippet \ref{codeSnippet:list_append}. 
In combination with the examples in chapter \ref{section:dependent_types}, this will help to understand the difference between generic types and dependent types.

\begin{codesnippet}[mathescape=true, caption={Definition of the list append function in Agda}, label={codeSnippet:list_append}]
_++_ : $\forall$ {$\ell$} {A : Set $\ell$} $\rightarrow \mathbb{L}$ A$\rightarrow \mathbb{L}$ A$\rightarrow \mathbb{L}$ A
  []        ++ ys = ys
  (x :: xs) ++ ys = x :: (xs ++ ys)
\end{codesnippet}

To call this function two implicit and two explicit arguments are required. 
Agda infers the correct type-level $\ell$ and the type A from the explicit arguments of type $\mathbb{L}$ A. 
It is required that both lists are of the same type. 
Because both input lists are of type $\mathbb{L}$ A it is possible to infer that the return value is also of type $\mathbb{L}$ A.

The second function for lists that is of interest is \emph{nth} which returns the nth element of an existing list.
In particular the comparison with the same function for vectors, which is shown in chapter \ref{section_dependent_types_example}, can help to understand dependent types.

One fundamental problem that the access to the specific element at position n has, is that the list might not be long enough.
In many common programming languages, this results in an exception. The concept of exceptions is, however, not included in Agda to maintain the properties of a total language.
A more detailed explanation can be found in section \ref{section:total_languages}.

To overcome this issue, an additional datatype \emph{maybe} is introduced\footnote{In other languages such as Java the concept of the \emph{maybe} datatype is known as \emph{Optional}}.
This datatype is either a wrapper around another element or indicates the absence of it.

\begin{codesnippet}[mathescape=true, caption={Definition of the maybe datatype in Agda}, label={codeSnippet:maybe_datatype}]
data maybe {$\ell$} (A : Set $\ell$) : Set $\ell$ where
  just : A $\rightarrow$ maybe A
  nothing : maybe A
\end{codesnippet}

The function \emph{nth} as shown in code snippet \ref{codeSnippet:list_nth} takes two implicit arguments for the type level and the type A itself.

\begin{codesnippet}[mathescape=true, caption={Definition of nth function in Agda}, label={codeSnippet:list_nth}]
nth : $\forall$ {$\ell$} {A : Set $\ell$} $\rightarrow \mathbb{N}$ $\rightarrow \mathbb{L}$ A $\rightarrow$ maybe A
nth _ [] = nothing
nth 0 (x :: xs) = just x
nth (suc n) (x :: xs) = nth n xs
\end{codesnippet}

In addition to the implicit arguments, an element of type $\mathbb{N}$, the index of the desired element, as well as the list itself, have to be specified.

The \emph{maybe} datatype solves the issue for the function \emph{nth} but wherever the nth function is used a case distinction is required to handle the nothing case.

\subsection{Total languages}\label{section:total_languages}
\todo{More content}
In comparison to other programming language, Agda is a so-called total programming language \cite{AgdaReadTheDocs}.
This means that every valid Agda programs will always terminate with the correct type. There is no exception to this.

It is fundamental for Agda to be total because computations can be already required during type checking.
If non-terminating computations were possible, typechecking itself would be undecidable\cite{agda_wiki_totality}.

To ensure the totality of a program beside type checking, coverage checking as well as termiantion checking are of great importance. 
Additionally \emph{strict positivity of constructors} as well as \emph{guardedness in coinductive programs} have to be checked, which are not discussed further in this publication.

Coverage checking verifies that no partial function is defined. A partial function is a function with pattern matching that does not cover all cases.
As oppossed to Haskell where partial functions are compiled successfully and only throw an exception when a not covered case is required at runtime, Agda does not compile partial functions.

To be able to check a program for termination Agda accepts only two different recursive schemas which can be proven to terminate.

In the case of \emph{primitive recursion} the recursive call must be executed with an argument that is exactly one constructor smaller than in the original call.

For example in the addition of Peano Number in code snippet \ref{codeSnippet:natural_number_addition} the arguments used in the recusive call have to be structurally smaller \cite{norell:deptyped}. 
This is the case as $m$ is structurally smaller than \emph{suc m} based on the definitions of the $\mathbb{N}$ datatype.

Beside \emph{primitive recursion} Agda is able to determine termination on \emph{structural recursion}.
This requires the argument of the recursive call to be a subexpression of the original argument.
As a contrast to \emph{primitive recursion} a recusive call with $m$ is also possible if the original argument was \emph{suc(suc m)}.

In contrast to this, non-total languages often also terminate with the correct type, but they may also not terminate or raise an exception because something was not as expected and the behaviour for this special case was not defined.
