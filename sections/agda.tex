\section{First steps in Agda}\label{section:first_steps_in_agda}
In the following chapter, a brief introduction to Agda is given. If you are experienced in any functional programming, it will be a short read or you might even skip some parts.

Agda is an advanced functional programming language. Its syntax is strongly related to Haskell but it differs concept-wise in some topics. 

One thing to mention is that Agda supports the full Unicode characters in the source code with only a few reserved symbols\footnote{\, . ; \{ \} ( ) @ " are reserved symbols\cite{AgdaReadTheDocsStructure}} 
and some reserved keywords\footnote{A full list of reserved keywords can be found at \cite{AgdaReadTheDocsStructure}}. 
Unicode symbols will be used a lot, especially for mathematical symbols.

Another important thing to mention is the integration into emacs, which works as an IDE and supports syntax highlighting as well as many agda specific features some of which are pointed out in this publication.

\subsection{Introduction example}\label{section:agda_introduction_example}
Lets first look at the data type definition for Peano natural numbers $\mathbb{N}$ shown in code snippet \ref{codeSnippet:natural_number}.

As most other functional languages Agda relies heavily on pattern matching. 

To define a new data type one simply has to specify the name of the type after the keyword \emph{data}. 
Directly followed after the name the type of the new datatype is defined as \emph{Set}. 
\emph{Set} is a special kind of type which is the type of types. This is required because in Agda every expression has a type\cite{norell:deptyped}.

After this basic definition two different constructors \emph{zero} and \emph{suc} are defined as shown in code snippet \ref{codeSnippet:natural_number}.
There is little meaning behind this short definition other than elements constructed with these operations are of type $\mathbb{N}$.
The only additional information is that suc requires another $\mathbb{N}$ to be constructed.

\begin{codesnippet}[mathescape=true, caption={Definition of the peano natural numbers data type in Agda}, label={codeSnippet:natural_number}]
data $\mathbb{N}$: Set where
  zero : $\mathbb{N}$
  suc  : $\mathbb{N} \rightarrow \mathbb{N}$
\end{codesnippet}

Elements of $\mathbb{N}$ can now be constructed by calling the constructors and used in functions with pattern matching. 
Code snippet \ref{codeSnippet:natural_number_constructor} shows the basic usage of the two different constructor.

\begin{codesnippet}[mathescape=true, caption={Some peano numbers}, label={codeSnippet:natural_number_constructor}]
x = zero
y = suc zero
z = suc (suc (suc zero))
\end{codesnippet}

Addition of Peano numbers can be defined in a very elegant way as an infix operator as shown in code snippet \ref{codeSnippet:natural_number_addition}.
These are functions which can be used in between its arguments.
Alternativelly it is also possible to call these functions in the normal prefix notation, but in this case the underscores are mandatory.
The underscores determine the place of its arguments.
Note that these operators are not restricted to two arguments, but allow more complex constructs such as $\text{if\_then\_else\_}$.

In case of the $\text{\_+\_}$ the infix call is $n + m$ and the equivalent prefix call is $\text{\_+\_} n m$

To be able to use multiple infix operators in the same expression it is necessary to specify the precedence of these.
With the three different keywords \emph{infix}, \emph{infixr} and \emph{infixl} the precedence as well as the associativity of the operator can be defined\footnote{The precendence factor defaults to 20 and can also be negative.}.

\begin{codesnippet}[mathescape=true, caption={Precedence and associativity of some Peano number operators}, label={codeSnippet:natural_number_precedence}]
infixl 40 _+_
infixl 20 _<_
\end{codesnippet}

The $\text{\_+\_}$ function takes two arguments of type $\mathbb{N}$ and returns another $\mathbb{N}$.
Based on the actual values of these arguments the pattern matching different values are returned.
If the first argument is \emph{zero} the function simply returns the second argument.
If the first argument matches the pattern suc m, where m can be of any Peano number, then the successor of m + n will be returned.
This will result in recursive calls to the $\text{\_+\_}$  function until the first argument is zero and the base case is reached.

\begin{codesnippet}[mathescape=true, caption={Peano numbers addition}, label={codeSnippet:natural_number_addition}]
_+_ : $\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}$
zero  + n = n
suc m + n = suc (m + n)
\end{codesnippet}

The second basic function of Peano numbers that will be used in this publication is the comparison function, also know as $\text{\_<\_}$, shown in code snippet \ref{codeSnippet:natural_number_less_than}

The type definition of the function states that it takes two arguments of $\mathbb{N}$ and returns a $\mathbb{B}$

The boolean data type $\mathbb{B}$ consists of two constructors \emph{tt} - representing true - and \emph{ff} - representing false - is shown in code snippet \ref{codeSnippet:boolean} for completeness.

\begin{codesnippet}[mathescape=true, caption={Definition of the boolean data type in Agda}, label={codeSnippet:boolean}]
data $\mathbb{B}$: Set where
  tt : $\mathbb{B}$
  ff  : $\mathbb{B}$
\end{codesnippet}

The $\text{\_+\_}$ function follows the same structure as the $\text{\_+\_}$ function, but has more different cases. 
This might not be the smallest possible definition for this property but it is certainly good readable.

\begin{codesnippet}[mathescape=true, caption={Peano numbers less-than}, label={codeSnippet:natural_number_less_than}]
_<_ : $\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{B}$
0 < 0 = ff
0 < (suc y) = tt
(suc x) < (suc y) = x < y
(suc x) < 0 = ff
\end{codesnippet}

The definition of the list datatype as seen in code snippet \ref{codeSnippet:list_datatype} is more complex as it contains a type parameter.
The application of another datatype to the list datatype results in an own unique type, this concept is called type-level function.

In this specific example, the function takes any type A at the type level $\ell$ and returns a new type, the concrete list type of A, at the same type level.\todo{research why this is required.}
For example $\mathbb{L}$ $\mathbb{N}$ for the list of Peano numbers.

$\ell$ is just an additional argument but with the usage of curly braces around $\ell$, we indicate that it is implicit and therefore should be inferred by Agda.
There is no guarantee that the type checker is able to infer implicit arguments and it fails otherwise.
But it is always possible to specificy the implicit arguments in the call by enclosing the argument in curly braces\cite{norell:deptyped}.

When a parameter in a datatype definition is declared it can be used in the types of the constructors. 
For example, the second constructor is defined as a function that takes an argument x of type A and a second argument xs of type $\mathbb{L}$ A and returns a new $\mathbb{L}$ A where A is exactly the type that was used to construct the type of the list.
\begin{codesnippet}[mathescape=true, caption={Definition of the list datatype in Agda}, label={codeSnippet:list_datatype}]
data $\mathbb{L}$ {$\ell$} (A : Set $\ell$) : Set $\ell$ where
  [] : $\mathbb{L}$ A
  _::_ : (x : A) (xs: $\mathbb{L}$ A) $\rightarrow \mathbb{L}$ A
\end{codesnippet}

With the help of the two constructors, it is possible to construct any possible list. As the next step the function which appends two lists of the same type. In combination with the examples in chapter \ref{section:dependent_types}, this will help to understand the difference between generic types and dependent types.

To call the append function, in code snippet \ref{codeSnippet:list_append} implemented as the ++ operator, two implicit and two explicit arguments are required. 
Agda infers the correct type-level $\ell$ and the type A from the explicit arguments of type $\mathbb{L}$ A. 
Note that both lists are required to have the same type.

Due to that fact, it is proven that x is of type A and xs, as well as ys, are of type $\mathbb{L}$ A and 
because the second constructor of $\mathbb{L}$ is used its also proven that the return value is also $\mathbb{L}$ A.

\begin{codesnippet}[mathescape=true, caption={Definition of the list append function in Agda}, label={codeSnippet:list_append}]
_++_ : $\forall$ {$\ell$} {A : Set $\ell$} $\rightarrow \mathbb{L}$ A$\rightarrow \mathbb{L}$ A$\rightarrow \mathbb{L}$ A
  []        ++ ys = ys
  (x :: xs) ++ ys = x :: (xs ++ ys)
\end{codesnippet}

The second function for lists that is of interest in this topic is \emph{nth}.
It is the function which returns the nth element of an existing list.

One problem that has to be solved is when there are not enough elements in the list to return the nth element. 
In common programming languages, this results in an exception which is not possible in Agda.
More details on this can be found in the following chapter \ref{section:total_languages}.

To overcome this, an additional data type \emph{maybe} - in other languages such as Java called Optional - is introduced.

This data type is essentially either a wrapper around another element or a placeholder for a not existing element.

\begin{codesnippet}[mathescape=true, caption={Definition of the maybe datatype in Agda}, label={codeSnippet:maybe_datatype}]
data maybe {$\ell$} (A : Set $\ell$) : Set $\ell$ where
  just : A $\rightarrow$ maybe A
  nothing : maybe A
\end{codesnippet}

The function \emph{nth} as shown in code snippet \ref{codeSnippet:list_nth} takes two implicit arguments for the type level and the type A itself.

In addition to the implicit arguments, an element of type $\mathbb{N}$, namely the index of the required element, as well as the list itself, have to be specified.
If the function is called with an empty list, either directly or in the recursion it will return the element nothing of type maybe indicating that no element was found at this position.

This solves the problem for the function nth but everywhere where the nth function is used a case distinction is required to handle this potential outcome.
\begin{codesnippet}[mathescape=true, caption={Definition of nth function in Agda}, label={codeSnippet:list_nth}]
nth : $\forall$ {$\ell$} {A : Set $\ell$} $\rightarrow \mathbb{N}$ $\rightarrow \mathbb{L}$ A $\rightarrow$ maybe A
nth _ [] = nothing
nth 0 (x :: xs) = just x
nth (suc n) (x :: xs) = nth n xs
\end{codesnippet}

\subsection{Total languages}\label{section:total_languages}
\todo{More content}
In comparison to other programming languages of all kind of different paradigms, Agda is a so-called total programming language \cite{AgdaReadTheDocs}.
This means that every valid Agda programs will always terminate with the correct type. There is no exception to this.

In contrast to this non-total languages often also terminate with the correct type, but they may also not terminate or raise an exception because something was not as expected and the behaviour for this special case was not defined.

Normal Agda programs will not compile if there is an incomplete definition detected, such as a possible case that is not covered.

For some programs, the check for termination can be done automatically, but sometimes Agda needs some "hints" from the developer to be able to prove the termination of the corresponding program.

To guarantee the termination of recursive definitions as seen in many defintions such as the addition of Peano Number in code snippet \ref{codeSnippet:natural_number_addition}, 
the arguments used in the recusive call have to be structurally smaller \cite{norell:deptyped}. 
This is the case as the $n$ is structurally smaller than $suc n$ based on the definitions of the $\mathbb{N}$ data type.

\subsection{Proofs in the program}\label{section:agda_proofs}
\todo{Maybe move this (or parts of it), as in some proofs such as x+0 dependent function types are used before they are introduced.}
In this section a small introduction to \emph{Propositions as Types}\cite{10.1145/2699407} will be given together with a few example in Agda. \emph{Proposition as Types} is also known under the names \emph{Curry-Howard Correspondence}\cite{10.5555/1076265} and \emph{Curry-Howard Isomorphism}\cite{10.1145/2841316} and many more.

Under all this different names the same interlinking between logic and programming is understood. There are three main statements of interest, pointed out by Wadler in \cite{10.1145/2699407}.

\emph{Propositions as types} states that each proposition in a logic has a corresponding type in the programming world and the other way around. 

\emph{Proofs as programs} follows from the fact that each proof is mapped to its proposition, as well as each program has its own type.

\emph{Simplification of proofs as evaluation of programs} states that for every step in simplification of a proof there is an operation how to evaluate the corresponding program.

This basically allows it that proofs can be directly represented in some programming languages.

Let us now consider a first small example in Agda.
In Agda it is possbile to define propositional equalities such as $zero + suc(zero) \equiv suc(zero)$. The type of this term is Set which is the type of types. This was the first application of propositions as types.
However this proposition is not proved yet. It is also possible to state false propositions such as $zero + suc(zero) \equiv zero$ without any compiler errors.

To prove this proposition a program of the type $zero + suc(zero) \equiv suc(zero)$ has to be implemented.
As a start a useful name has to be considered. Note that you are not very free in terms of naming and even can use operators used to define names, as it will only be treated as separate symbol with spaces around it. Possible names are $1+0=1$ or $zeroAddition$ and many more. 
If you are coding in a team please make sure to define naming guidelines because it can be quite confusing to use the same operators in the name as in type description.

$$\text{0+1=1} : zero + suc(zero) \equiv suc(zero)$$

It is possible for Agda to simplify this type to $suc(zero) \equiv suc(zero)$ because $suc(zero) + zero$ is definitionally equal to $suc(zero)$ . Where definitionally equal means that Agda is able to simplify both terms to the same value and they are therefore interchangable.
The proof is now simply as both sides are equal as well. Agda just needs this hint by assigning the value $refl$ to it which means reflexivity and requires both sides of the $\equiv$ operator to be definitionally equal.

$$\text{0+1=1} = refl$$

If this program compiles successfully, the proof is completed.

This proof is just proven for these specific values, similiar to a single test case. But it is possible to extend this proof to any Peano number $\mathbb{N}$. 
To do this we use the universal quantifier $\forall$, which is also common in mathematics, to state that the following property should hold for every possible assignment\cite{plfa2019}.
The $\forall$ symbol is a reserved keyword in Agda.

The new proposition in code snippet \ref{codeSnippet:zero_plus_x_agda} is now a little more complex but still comprehensible. It states that for every x of type $\mathbb{N}$ the following equivalence holds. 
Because an variable \emph{x} is defined in the type, the program requires an input argument. In this code snippet this argument gets assigned to the variable \emph{a}.

As the first constructor of the addition of $\mathbb{N}$ is $zero + n = n$ refl is the proof.

\begin{codesnippet}[mathescape=true, caption={Proof of addition to zero in Agda}, label={codeSnippet:zero_plus_x_agda}]
0+x : $\forall$ (x : $\mathbb{N}$) $\rightarrow$ zero + x $\equiv$ x
0+x a = refl
\end{codesnippet}

If the addition happens in a different order and \emph{zero} gets added to \emph{x}, as shown in code snippet \ref{codeSnippet:x_plus_zero_agda}, the proof gets yet a little bit more complicated. 
The reason for this lies in the definition of addition.
Because on the recursion happens on the second argument it is no longer possible for Agda to determine that these terms are definitionally equal and requires the programmer to add additional hints to be able to prove this indeed.

It is notable that it is possible to pattern match in proofs as they are just normal programms. 
For the base case \emph{zero + zero $\equiv$ zero}, \emph{refl} is still enough but on the case where \emph{a} is not \emph{zero} but \emph{suc(x)} the \emph{rewrite} directive is required.

The \emph{rewrite} directive can be used to transform parts of the original problem. If a proof exists that A $\equiv$ B then rewrite will replace A with B in the instantiated type.

But how does this really work?
The original proof we tried to archive is $x + zero \equiv x$ where x is instantiated with \emph{suc(a)} or more precisely $suc(a) + zero \equiv suc(a)$
As $suc(a) + zero$ is definitionally equal to $suc(a + zero)$ regarding the second constructor of addition in code snippet \ref{codeSnippet:natural_number_addition}, this can also be written as $suc(a + zero) \equiv suc(a)$.

If now the proof that $a + 0 \equiv a$ gets applied to this the result will be the desired $suc(a) \equiv suc(a)$. The proof $a + 0 \equiv a$ gets archived by calling the proof recursively on $a$ instead of $suc(a)$

\begin{codesnippet}[mathescape=true, caption={Proof of addition to zero in Agda}, label={codeSnippet:x_plus_zero_agda}]
x+0 : $\forall$ (x : $\mathbb{N}$) $\rightarrow$ x + zero $\equiv$ x
x+0 zero = refl
x+0 suc(a) rewrite x+0 a = refl
\end{codesnippet}

This kind of proof is called proof by induction in mathematics and is actually very common.
The important thing to remember, as in every recursion, is that a base case as well as partial solution step are required.