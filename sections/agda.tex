\section{First steps in Agda}\label{section:first_steps_in_agda}
The idea of this chapter is to give the reader a brief overview how Agda and external proofs (especially in agda) work. This is helpful as a contrast to the following chapters. 
In chapter \ref{section:internal_vs_external_verification} some differences are highlighted. The example therefore will most probably be based on the list to be able to compare it later with the vector type.

In the following chapter a brief intoduction to agda is given. If you are experienced in any functional programming, it will be a short read or you might even skip some parts.

Agda is a advanced functional programming language. Its syntax is strongly related to haskell but it differs conceptwise in some topics. 
One thing to mention is that agda supports the full unicode characters in the source code with only a few reserved symbols\footnote{ are reserved symbols\cite{AgdaReadTheDocsStructure}} 
and some reserved keywords\footnote{A full list of reserved keywords can be found at \cite{AgdaReadTheDocsStructure}}. This will be used a lot especially for mathematical symbols.

Another important thing to mention is the integration into emacs, which works as an IDE and beside syntax highlighting supports many agda specific features some of which are pointed out in this publication.

\subsection{Introduction example}\label{section:agda_introduction_example}
As a start lets look at the so called datatype definition for Peano natural numbers. $\mathbb{N}$
Placeholder: A short intoduction to agda. (Datatype definitions, pattern matching, normalization, etc).
As most other functional languages Agda relies heavely on pattern matching. 
To define a new datatype one simply has to specify the name of the type after the keyword data. Directly followed after the name the type of the new datatype is defined as Set. 
Set is a special kind of type which is the type of types. This is required because in Agda every expression has a type. \todo{cite?}
After this basic definition two different constructors "zero" and "suc" are defined. 
There is little meaning behind this short definition other than elements constructed with this operations are of type $\mathbb{N}$.
The only additional information is that suc requires another $\mathbb{N}$ to be constructed.

\begin{codesnippet}[mathescape=true, caption={Definition of the peano natural numbers datatype in Agda}, label={codeSnippet:natural_number}]
data $\mathbb{N}$: Set where
  zero : $\mathbb{N}$
  suc : $\mathbb{N} \rightarrow \mathbb{N}$
\end{codesnippet}

Elements of $\mathbb{N}$ can now be constructed by calling the constructors and used in functions with pattern matching.
\begin{codesnippet}[mathescape=true, caption={Some peano numbers}, label={codeSnippet:natural_number_constructor}]
zero
suc zero
suc (suc (suc zero))
\end{codesnippet}
\begin{codesnippet}[mathescape=true, caption={Peano numbers addition}, label={codeSnippet:natural_number_addition}]
_+_ : $\mathbb{N} \rightarrow \mathbb{N}$
zero  + n = n
suc m + n = suc (m + n)
\end{codesnippet}


The definition of the list datatype as seen in code snippet \ref{codeSnippet:list_datatype} is more complex as it contains a type parameter. The application of another datatype to the list datatype results in an own unique type, this concept is called type-level function. 

In this specific example the function takes any type A at the type level $\ell$ and returns a new type, the concrete list type of A, at the same type level.\todo{research why this is required.}
For example $\mathbb{L}$ $\mathbb{N}$ for the list of peano numbers.

\todo{maybe move this "list" block closer to dependent types to be able to compare it better.}
Actually it is possible to consider $\ell$ as an additional argument but with the usage of curly braces around $\ell$ we indicate that it should be inferred by Agda.
When a parameter in a datatype definition is declared it can be used in the types of the constructors. 
For example the second constructor is defined as a function that take an argument x of type A and another argument xs of type $\mathbb{L}$ A and returns a new $\mathbb{L}$ A where A is exactly the type that was used to construct the type of the list.
\begin{codesnippet}[mathescape=true, caption={Definition of the list datatype in Agda}, label={codeSnippet:list_datatype}]
data $\mathbb{L}$ {$\ell$} (A : Set $\ell$) : Set $\ell$ where
  [] : $\mathbb{L}$ A
  _::_ : (x : A) (xs: $\mathbb{L}$ A) $\rightarrow \mathbb{L}$ A
\end{codesnippet}

With the help of the two constructors it is possible to construct any possible list. As the next step the function which appends two lists of the same type. In combination with the examples in chapter \ref{section:dependent_types} this will help to understand the difference between generic types and dependent types.

To call the append function, in code snippet \ref{codeSnippet:list_append} implemented as the ++ operator two implicit and two explicit arguments are required. 
Agda infers the correct type-level $\ell$ and the type A from the explicit arguments of type $\mathbb{L}$ A. Note that both lists are required to have exactly the same type.
Due to that fact it is proven that x is of type A and xs aswell as ys are of type $\mathbb{L}$ A. Because the second constructor of $\mathbb{L}$ is used its also proven that the return value 
\todo{Research and explain forall}
\begin{codesnippet}[mathescape=true, caption={Definition of the list append function in Agda}, label={codeSnippet:list_append}]
_++_ : $\forall$ {$\ell$} {A : Set $\ell$} $\rightarrow \mathbb{L}$ A$\rightarrow \mathbb{L}$ A$\rightarrow \mathbb{L}$ A
  []        ++ ys = ys
  (x :: xs) ++ ys = x :: (xs ++ ys)
\end{codesnippet}

The second function for lists that is of interest in this topic is nth. It is the function which returns the nth element of an existing list.
One problem that has to be solved is when there are not enough elements in the list to return the nth element. 
In many programming languages this results in an exception which is not possible in agda.
More details on this can be found in the following chapter \ref{section:total_languages}.

To overcome this an additional datatype "maybe" - in other languages such as Java called optional - needs to be introduced.
This datatype is essentially either a wrapper around another element or a placeholder for a not existing element.
\begin{codesnippet}[mathescape=true, caption={Definition of the maybe datatype in Agda}, label={codeSnippet:maybe_datatype}]
data maybe {$\ell$} (A : Set $\ell$) : Set $\ell$ where
  just : A $\rightarrow$ maybe A
  nothing : maybe A
\end{codesnippet}

The function "nth" as shown in code snippet \ref{codeSnippet:list_nth} takes two implizit arguments for the type-level and the type A itself.
In addition to the implizit arguments an element of type $\mathbb{N}$ namely the index of the required element aswell as the list itself have to be specified.
If the function is called with an empty list, either directly or in the recursion it will return the element nothing of type maybe indicating that no element was found at this position.

This solves the problem for the function nth but everywhere where the nth function is used a case distinction is required to handle this potential outcome.
\begin{codesnippet}[mathescape=true, caption={Definition of nth function in Agda}, label={codeSnippet:list_nth}]
nth : $\forall$ {$\ell$} {A : Set $\ell$} $\rightarrow \mathbb{N}$ $\rightarrow \mathbb{L}$ A $\rightarrow$ maybe A
nth _ [] = nothing
nth 0 (x :: xs) = just x
nth (suc n) (x :: xs) = nth n xs
\end{codesnippet}

\subsection{Total languages}\label{section:total_languages}
Placeholder: Agda and other languages based on type theory are total languages in the sense that a program e of type T will always terminate with a value in T. 
No runtime error can occur and no nonterminating programs can be written (unless explicitly requested by the programmer)\cite{AgdaReadTheDocs}.

In relation to other programming languages of all kind of different paradigms, Agda is a so called total programming language \cite{AgdaReadTheDocs}.
This means that every valid Agda programs will always terminate with the correct type. There is literally no exception to this.

In contrast to this non total languages often also terminate with the correct type, but they may also not terminate or raise an exception due to the fact that something was not as expected and the behaviour for special case was not defined.

Normal Agda programs will not compile if there is an incomplete definition such as a side case that is not covered.

For some programs the check for termination can be done automatically, but sometimes Agda needs some "hints" from the developer to be able to proof the termination of the corresponding program.

\subsection{Proofs in the program}
Placeholder: Introduction to proofs (external verification) in agda with a few examples.
Curry-Howard isomorphism.
\cite{norell:deptyped, 10.1145/2841316, plfa2019}

