\section{Introduction}\label{section:introduction}
Statically typed programming languages are very common nowadays and they possess some very useful features to detect programming errors at compile time.
\todo{rewrite to be more clear about the history of generics and maybe its relation to lamda calculus}
\todo{add context about functional programming languages such as haskell}
With the introduction of type parameters to many different popular programming languages such as Java\footnote{Under the name of Generics in JDK 5 in 2004\cite{JDK5}},
 C\#\footnote{Under the name of Generics in .NET Framework 2.0 in 2005\cite{dotnet20}} or C++\footnote{Under the name of templates} a big improvement of type safety was brought to the mainstream programming languages and has become indispensable.

With the help of this language feature, common type errors can now be detected at compile time instead of runtime as shown in the following code snippets \ref{codeSnippet:list_without_generic} and \ref{codeSnippet:list_with_generic}.

\begin{adjustbox}{width=\columnwidth}
\begin{codesnippet}[caption={List without generic argument}, label={codeSnippet:list_without_generic}]
List v = new ArrayList();
v.add(1);
v.add("test");
Integer e1 = (Integer)v.get(0) // Type has to be specified
Integer e2 = (Integer)v.get(1); //Type error at run time
\end{codesnippet}
\end{adjustbox}
\begin{adjustbox}{width=\columnwidth}
\begin{codesnippet}[escapeinside={(*}{*)}, caption={List with type argument}, label={codeSnippet:list_with_generic}]
List<Integer> v = new ArrayList<(*\highlight{Integer}*)>();
v.add(1);
v.add("test"); //Type error at compile time
Integer e1 = v.get(0);
String e2 = (String)v.get(1); //Type error at compile time
\end{codesnippet}
\end{adjustbox}

Similarly, the concept of dependent types tries to detect additional programming errors at compile time. But instead of depending on a type parameter, it depends on a specific value. 

The easiest and probably the most understandable usage of dependent types is the extension of a list data type with the length of the list. 
One of the common run time errors\todo{small search for a run time error statistic} is caused by accessing an invalid list index as shown in code snippet \ref{codeSnippet:array_index_error}.

\begin{codesnippet}[caption={ArrayList index error}, label={codeSnippet:array_index_error}]
List<Integer> v = new ArrayList<Integer>();
v.add(1);
Integer i = v.get(1); // run time error
\end{codesnippet}

Of course, it is known how many elements this list contains but this information is not available at compile time. 
However, it would be useful if this kind of error would be detected by the compiler. 

Now imagine that it would be possible to supply an additional parameter to the type which specifies the length of the list as shown in code snippet \ref{codeSnippet:hypothetical_dependet_types}. 
The compiler would now be able to detect the access to the wrong index and stop the compilation with an appropriate error.

\begin{codesnippet}[escapeinside={(*}{*)}, caption={ArrayList with size parameter}, label={codeSnippet:hypothetical_dependet_types}]
List<Integer,(*\highlight{0}*)> v = new ArrayList<Integer,(*\highlight{0}*)>();
v.add(1);
Integer i = v.get(1); // compile time error
\end{codesnippet}


Note that the example in code snippet \ref{codeSnippet:hypothetical_dependet_types} is purely fictional and beside the missing language feature other problems such as the mutability of ArrayLists exist in this example.

To be able to do this, some properties must be fulfilled by the language and the specific type. 
As mentioned previously values of such types must be immutable.\todo{more research regarding total languages} 

As the concept of dependent types directly relates to the lambda calculus most of the currently known implementations are found in functional languages. 
In this publication, all concrete code examples are based on Agda, as there are different beginner-friendly tutorials available as well as literature related to dependent types.\todo{references to tutorials and literature}

An introduction to Agda can be found in the following chapter \ref{section:first_steps_in_agda}.

Basic knowledge of lambda calculus as well as any functional programming language, such as Haskell, is recommended to benefit the most from the following chapters.
